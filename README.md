# Udacity SDC Nanodegree
## Term 3 - Project 11
## Path Planning Project


The aim of this project was to write a path planner for the term 3 simulator.

*Machine setup:*
* Intel i5-6500 CPU
* 16GB RAM
* Nvidia GTX 1060 GPU, 6GB VRAM
* Linux Mint 18 (based on Ubuntu 16.04)

*Problems encountered:*

* `getXY()`-function was unsuitable for transforming the quintic curve (s(t),d(t)) into Cartesian coordinates. Inspection of this function revealed that it utilizes linear interpolation between the 42 map points. This however leads to the phenomenon that the curved line will be broken at the map points.



#### Behavior Planner
The Behavior Planner is based on the principle that it plans a trajectory of a fixed distance of ![](https://latex.codecogs.com/gif.latex?%5CDelta%20s) ahead of the ego vehicle (![](https://latex.codecogs.com/gif.latex?%5CDelta%20s) = 90 meters).
The Trajectory Class accepts the total

* LC - Lane Keep
* LCL - Lane Change Left
* LCR - Lane Change Right

Figure ?? illustrates the state machine:

![](./images/Drawing1.png)

`current_lane` switches to `intended_lane` when the ego vehicle has entered the intended lane.

As indicated in the following figure, we subdivide the road in front of the vehicle (and to some extend also behind) into "buckets":

A for-loop iterates over all cars in the proximity of the ego vehicle (these where already filtered in a loop in the main()-function) and places them into a backet.
Each bucket has a certain cost. For example, cars farer away from the ego-vehicle are given a lower cost, and vehicles in the proximity of the ego vehicle are given a higher cost.

![](./images/Drawing2.png)


A second cost function is designed relatively straightforward

The advantage of this "bucket-approach" seems to be much less dependency on the cost-functions' weight, and therefore less need for fine-tuning. Also, the complexity of the operation is significantly less than other approaches like tracing the trajectories of the target vehicles.



#### Trajectory Generation
The Trajectory Class accepts the total time ![](https://latex.codecogs.com/gif.latex?%5CDelta%20T) as input as well as initial and final positions, and initial and final longitudinal velocities. The total time ensures that the mean speed along the interior of the trajectory stays in a range definied by the initial and final velocities. E.g., choosing ![](https://latex.codecogs.com/gif.latex?%5CDelta%20T) relatively large leads to the ego vehicle first decelerating and then accelerating again. Choosing ![](https://latex.codecogs.com/gif.latex?%5CDelta%20T) relatively large leads to the ego vehicle first accelerating and then decelerating again.



#### getXY()-function
The `getXY()`-function is of critical importance. As described above, it had to be modified in order to become useful.

![](https://latex.codecogs.com/gif.latex?%5C%7B%20P_0%2C%20P_1%2C%20P_2%2C%20P_3%20%5C%7D)

We denote by K_1(t) the spline generated by the three points ![](https://latex.codecogs.com/gif.latex?%5Cinline%20%5Cmathcal%7BK%7D_0%20%3D%20%5C%7B%20P_0%2C%20P_1%2C%20P_2%20%5C%7D)
(red line in the illustration), and by K_2 the spline generated by
![](https://latex.codecogs.com/gif.latex?%5Cmathcal%7BK%7D_1%20%3D%20%5C%7B%20P_1%2C%20P_2%2C%20P_3%20%5C%7D) (green line).
The interpolated line is the blue one.


The interpolation algorithm makes use of an interesting idea by fellow *Udacity SDC-ND student* [Piermarco Pascale][1].  He proposed a norm
However, as his approach is incredibly accurate, it is - due to it's computational complexity - useless for practical purposes. We modified it by exchanging the integration part with splines. For a detailed description of algorithm, cf. the description below.

As for he spline library, we make use of the [library by Tino Kluge][2], as suggested in the lectures. It picks the closest two map points in front of the ego vehicle, and the closest two map points behind it. It then generates two spline curves between the first three points and the last three points.

![](./images/Drawing3.png)

The two splines are not identical in the section between points ![](https://latex.codecogs.com/gif.latex?P_1) and ![](https://latex.codecogs.com/gif.latex?P_2). Let ![](https://latex.codecogs.com/gif.latex?d_1) and ![](https://latex.codecogs.com/gif.latex?d_2) be the s-distance of the car to ![](https://latex.codecogs.com/gif.latex?P_2) and ![](https://latex.codecogs.com/gif.latex?P_1), respectively. In order to find a smooth approximation for the whole track, we define the following weights:

![](https://latex.codecogs.com/gif.latex?p%20%3D%20d_2%5E%7B-2%7D) and ![](https://latex.codecogs.com/gif.latex?q%3D%20d_1%5E%7B-2%7D).

We then define further:
![](https://latex.codecogs.com/gif.latex?n%20%3D%20p&plus;q)

The interpolated XY-position is then defined as:

![](https://latex.codecogs.com/gif.latex?X%28s%2Cd%29%20%3D%20%5Cfrac%7Bp%20%5Ccdot%20K_1%28s%29%20&plus;%20q%20%5Ccdot%20K_2%28s%29%7D%7Bn%7D)

In order to understand the meaning of this expression, consider again the diagram above: The ego vehicle is by definition located in between the two points ![](https://latex.codecogs.com/gif.latex?P_0) and ![](https://latex.codecogs.com/gif.latex?P_1). As it continues to drive forward, the distance to ![](https://latex.codecogs.com/gif.latex?P_0), becomes larger, i.e. ![](https://latex.codecogs.com/gif.latex?d_1%20%5Cto%20%5CDelta%20d)),
and the distance to ![](https://latex.codecogs.com/gif.latex?P_1) becomes smaller, i.e. ![](https://latex.codecogs.com/gif.latex?d_2%20%5Cto%200).
So for the interpolated position:

![](https://latex.codecogs.com/gif.latex?%5Clim_%7Bs%5Cto%20P_2%7D%20%5Cfrac%7Bp%5Ccdot%20K_1%28s%29&plus;q%5Ccdot%20K_2%28s%29%7D%7Bn%7D%20%3D%20%5Clim_%7Bs%5Cto%20P_2%7D%20%5Cfrac%7Bp%7D%7Bn%7D%20K_1%28s%29%20&plus;%20%5Clim_%7Bs%5Cto%20P_2%7D%20%5Cfrac%7Bq%7D%7Bn%7D%20K_2%28s%29%3D%200%20&plus;%20K_2%28P_2%29)

since

![](https://latex.codecogs.com/gif.latex?%5Clim_%7Bs%5Cto%20P_1%7D%20%5Cfrac%7Bp%7D%7Bn%7D%20%3D%20%5Clim_%7Bq%5Cto%20%5Cinfty%7D%20%5Cfrac%7B1%7D%7B1&plus;q%5E2/p%5E2%7D%20%3D%200)

and

![](https://latex.codecogs.com/gif.latex?%5Clim_%7Bs%5Cto%20P_1%7D%20%5Cfrac%7Bq%7D%7Bn%7D%20%3D%20%5Clim_%7Bq%5Cto%20%5Cinfty%7D%20%5Cfrac%7B1%7D%7B1&plus;p%5E2/q%5E2%7D%20%3D%201)

We see that the contribution of the first spline, ![](https://latex.codecogs.com/gif.latex?K_1), is zero when the ego vehicle located at ![](https://latex.codecogs.com/gif.latex?P_2). As soon as the ego vehicle crosses this point, ![](https://latex.codecogs.com/gif.latex?P_0) is deleted from the list of waypoints, and the next point ahead of ![](https://latex.codecogs.com/gif.latex?P_3) is added. If the new list of points is

![](https://latex.codecogs.com/gif.latex?%5C%7BP%27_0%2C%20P%27_1%2C%20P%27_2%2C%20P%27_3%5C%7D),

then ![](https://latex.codecogs.com/gif.latex?P%27_2%3DP_3), ![](https://latex.codecogs.com/gif.latex?P%27_1%3DP_2), and ![](https://latex.codecogs.com/gif.latex?P%27_0%3DP_1).

The interpolation is can be done with new splines ![](https://latex.codecogs.com/gif.latex?K%27_2) and ![](https://latex.codecogs.com/gif.latex?K%27_1) where ![](https://latex.codecogs.com/gif.latex?K%27_1%3DK_2).




## Analysis

#### Failed attempts
Since there were only relatively little guidelines for this project,

**Stochastic trajectory generation**
By this we mean choosing random endpoints for the trajectories and choosing the one with the lowest costs. The problem with this approach is that while it worked in principle, it has eaten too many resources.

**Calculating cost of trajectory**
I.e. predicting the movement of each target vehicle and calculating collision trajectories. Again, this methods has taken too much resources. Calculating a few dozen trajectories takes a few seconds.



#### Possible Modifications
One possible modification which I have only shortly delved into is the possibility to enable near real-time path planning akin to the MPC project.



#### Comment on the Provided Framework
Most students I have communicated with share the same opinion that fixing the was quite distracting from the primary objective of

First of all, instead of relying on a single `main.cpp`-file, I chose to split the code into several different files. These are (omitting header files)

* `main.cpp`: Contains the main loop which communicates with
* `statemachine.cpp`: Contains the state machine and cost functions.
* `trajectory.cpp`: Contains the `Trajectory`-class. An instance of `Trajectory` is
* `common.cpp`: A collection of functions, such as the affine coordinate transformations `global2local()` and `local2global()`.
* `maptool.cpp`: `Maptool`-class which can be considered as a singleton. Its members are useful functions such as `getXY()` and `getFrenet()`.




## Conclusion
Although the project was extremely interesting, the largest portion of time had to be dedicated to secondary objectives. These included trying out new architectures for the code, and rewriting helper functions, especially the notorious `getXY()`.
One lesson I have learned is that computational complexity is a huge issue when developing algorithms for self-driving cars. Concepts which have been introduced in the lectures, for example stochastic trajectory generation seem to be unfeasible for usage in the simulator.

At the time of submission, I have not been fully satisfied by the architecture I have developed.


The latex-graphics were generated by https://www.codecogs.com/eqnedit.php.


[1]: https://discussions.udacity.com/t/a-more-refined-getxy-function/666827
[2]: http://kluge.in-chemnitz.de/opensource/spline/
